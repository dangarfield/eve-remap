
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
'use strict';

const loadData = () => {
    const dataString = localStorage.getItem('eve-remap');
    if (dataString) {
        return JSON.parse(dataString)
    }
    return {}
};
const saveData = (key, value) => {
    const existingData = loadData();
    const newData = { ...existingData, [key]: value };
    const newDataString = JSON.stringify(newData);
    localStorage.setItem('eve-remap', newDataString);
};
const clearData = (key) => {
    const existingData = loadData();
    delete existingData[key];
    const newDataString = JSON.stringify(existingData);
    localStorage.setItem('eve-remap', newDataString);
};
// module.exports = {}

var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var base64url$3 = { exports: {} };
var base64url$2 = {};
var padString$1 = {};
Object.defineProperty(padString$1, "__esModule", { value: true });
function padString(input) {
  var segmentLength = 4;
  var stringLength = input.length;
  var diff = stringLength % segmentLength;
  if (!diff) {
    return input;
  }
  var position = stringLength;
  var padLength = segmentLength - diff;
  var paddedStringLength = stringLength + padLength;
  var buffer = Buffer.alloc(paddedStringLength);
  buffer.write(input);
  while (padLength--) {
    buffer.write("=", position++);
  }
  return buffer.toString();
}
padString$1.default = padString;
Object.defineProperty(base64url$2, "__esModule", { value: true });
var pad_string_1 = padString$1;
function encode$1(input, encoding) {
  if (encoding === void 0) {
    encoding = "utf8";
  }
  if (Buffer.isBuffer(input)) {
    return fromBase64(input.toString("base64"));
  }
  return fromBase64(Buffer.from(input, encoding).toString("base64"));
}
function decode$1(base64url2, encoding) {
  if (encoding === void 0) {
    encoding = "utf8";
  }
  return Buffer.from(toBase64(base64url2), "base64").toString(encoding);
}
function toBase64(base64url2) {
  base64url2 = base64url2.toString();
  return pad_string_1.default(base64url2).replace(/\-/g, "+").replace(/_/g, "/");
}
function fromBase64(base64) {
  return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBuffer(base64url2) {
  return Buffer.from(toBase64(base64url2), "base64");
}
var base64url$1 = encode$1;
base64url$1.encode = encode$1;
base64url$1.decode = decode$1;
base64url$1.toBase64 = toBase64;
base64url$1.fromBase64 = fromBase64;
base64url$1.toBuffer = toBuffer;
base64url$2.default = base64url$1;
(function(module) {
  module.exports = base64url$2.default;
  module.exports.default = module.exports;
})(base64url$3);
var base64url = base64url$3.exports;
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i = 0; i < chars.length; i++) {
  lookup[chars.charCodeAt(i)] = i;
}
var encode = function(arraybuffer) {
  var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
  for (i = 0; i < len; i += 3) {
    base64 += chars[bytes[i] >> 2];
    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    base64 += chars[bytes[i + 2] & 63];
  }
  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + "=";
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + "==";
  }
  return base64;
};
async function getRandomString(length) {
  const numBytes = Math.floor(length / 2);
  const array = new Uint8Array(numBytes);
  window.crypto.getRandomValues(array);
  return [...array].map((x) => x.toString(16).padStart(2, "0")).join("");
}
async function createHash(payload) {
  const data = new TextEncoder().encode(payload);
  const digest = await window.crypto.subtle.digest("SHA-256", data);
  return base64url.fromBase64(encode(digest));
}
const encoder = new TextEncoder();
const decoder = new TextDecoder();
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf;
}
const decodeBase64 = (encoded) => {
  return new Uint8Array(atob(encoded).split("").map((c) => c.charCodeAt(0)));
};
const decode = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch (_a) {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};
class JOSEError extends Error {
  constructor(message) {
    var _a;
    super(message);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
  }
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
}
class JWTClaimValidationFailed extends JOSEError {
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
  }
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
}
class JWTExpired extends JOSEError {
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
  }
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
}
class JOSEAlgNotAllowed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
}
class JOSENotSupported extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
}
class JWSInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
}
class JWTInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
}
class JWSSignatureVerificationFailed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
}
var crypto$1 = crypto;
function isCryptoKey(key) {
  try {
    return key != null && typeof key.extractable === "boolean" && typeof key.algorithm.name === "string" && typeof key.type === "string";
  } catch (_a) {
    return false;
  }
}
function isCloudflareWorkers() {
  return typeof WebSocketPair === "function";
}
function isNodeJs() {
  try {
    return process.versions.node !== void 0;
  } catch (_a) {
    return false;
  }
}
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash) {
  return parseInt(hash.name.substr(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.substr(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.substr(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.substr(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case (isNodeJs() && "EdDSA"): {
      if (key.algorithm.name !== "NODE-ED25519" && key.algorithm.name !== "NODE-ED448")
        throw unusable("NODE-ED25519 or NODE-ED448");
      break;
    }
    case (isCloudflareWorkers() && "EdDSA"): {
      if (!isAlgorithm(key.algorithm, "NODE-ED25519"))
        throw unusable("NODE-ED25519");
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
var invalidKeyInput = (actual, ...types2) => {
  let msg = "Key must be ";
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
};
var isKeyLike = (key) => {
  return isCryptoKey(key);
};
const types = ["CryptoKey"];
const isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var isDisjoint$1 = isDisjoint;
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
var checkKeyLength = (alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "oct": {
      switch (jwk.alg) {
        case "HS256":
        case "HS384":
        case "HS512":
          algorithm = { name: "HMAC", hash: `SHA-${jwk.alg.substr(-3)}` };
          keyUsages = ["sign", "verify"];
          break;
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
          algorithm = { name: "AES-GCM" };
          keyUsages = ["encrypt", "decrypt"];
          break;
        case "A128KW":
        case "A192KW":
        case "A256KW":
          algorithm = { name: "AES-KW" };
          keyUsages = ["wrapKey", "unwrapKey"];
          break;
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
          algorithm = { name: "PBKDF2" };
          keyUsages = ["deriveBits"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.substr(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.substr(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.substr(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case ((isCloudflareWorkers() || isNodeJs()) && "OKP"):
      if (jwk.alg !== "EdDSA") {
        throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      switch (jwk.crv) {
        case "Ed25519":
          algorithm = { name: "NODE-ED25519", namedCurve: "NODE-ED25519" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case (isNodeJs() && "Ed448"):
          algorithm = { name: "NODE-ED448", namedCurve: "NODE-ED448" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "crv" (Subtype of Key Pair) Parameter value');
      }
      break;
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
const parse = async (jwk) => {
  var _a, _b;
  const { algorithm, keyUsages } = subtleMapping(jwk);
  const rest = [
    algorithm,
    (_a = jwk.ext) !== null && _a !== void 0 ? _a : false,
    (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages
  ];
  if (algorithm.name === "PBKDF2") {
    return crypto$1.subtle.importKey("raw", decode(jwk.k), ...rest);
  }
  const keyData = __spreadValues({}, jwk);
  delete keyData.alg;
  return crypto$1.subtle.importKey("jwk", keyData, ...rest);
};
var asKeyObject = parse;
async function importJWK(jwk, alg, octAsKeyObject) {
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  if (typeof alg !== "string" || !alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
      if (octAsKeyObject) {
        return asKeyObject(__spreadProps(__spreadValues({}, jwk), { alg, ext: false }));
      }
      return decode(jwk.k);
    case "RSA":
      if (jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return asKeyObject(__spreadProps(__spreadValues({}, jwk), { alg }));
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}
const symmetricTypeCheck = (key) => {
  if (key instanceof Uint8Array)
    return;
  if (!isKeyLike(key)) {
    throw new TypeError(invalidKeyInput(key, ...types, "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
};
const asymmetricTypeCheck = (key, usage) => {
  if (!isKeyLike(key)) {
    throw new TypeError(invalidKeyInput(key, ...types));
  }
  if (key.type === "secret") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
const checkKeyType = (alg, key, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(key);
  } else {
    asymmetricTypeCheck(key, usage);
  }
};
var checkKeyType$1 = checkKeyType;
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
const validateAlgorithms = (option, algorithms) => {
  if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return void 0;
  }
  return new Set(algorithms);
};
var validateAlgorithms$1 = validateAlgorithms;
function subtleDsa(alg, namedCurve) {
  const length = parseInt(alg.substr(-3), 10);
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: `SHA-${length}`, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: `SHA-${length}`, name: "RSA-PSS", saltLength: length >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: `SHA-${length}`, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: `SHA-${length}`, name: "ECDSA", namedCurve };
    case ((isCloudflareWorkers() || isNodeJs()) && "EdDSA"):
      return { name: namedCurve, namedCurve };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
function getCryptoKey(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalidKeyInput(key, ...types));
    }
    return crypto$1.subtle.importKey("raw", key, { hash: `SHA-${alg.substr(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalidKeyInput(key, ...types, "Uint8Array"));
}
const verify = async (alg, key, signature, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "verify");
  checkKeyLength(alg, cryptoKey);
  const algorithm = subtleDsa(alg, cryptoKey.algorithm.namedCurve);
  try {
    return await crypto$1.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch (_a) {
    return false;
  }
};
var verify$1 = verify;
async function flattenedVerify(jws, key, options) {
  var _a;
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    const protectedHeader = decode(jws.protected);
    try {
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch (_b) {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!isDisjoint$1(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = __spreadValues(__spreadValues({}, parsedProt), jws.header);
  const extensions = validateCrit(JWSInvalid, new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validateAlgorithms$1("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  checkKeyType$1(alg, key, "verify");
  const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
  const signature = decode(jws.signature);
  const verified = await verify$1(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    payload = decode(jws.payload);
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return __spreadProps(__spreadValues({}, result), { key });
  }
  return result;
}
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return __spreadProps(__spreadValues({}, result), { key: verified.key });
  }
  return result;
}
var epoch = (date) => Math.floor(date.getTime() / 1e3);
const minute = 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
var secs = (str) => {
  const matched = REGEX.exec(str);
  if (!matched) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[1]);
  const unit = matched[2].toLowerCase();
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      return Math.round(value);
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      return Math.round(value * minute);
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      return Math.round(value * hour);
    case "day":
    case "days":
    case "d":
      return Math.round(value * day);
    case "week":
    case "weeks":
    case "w":
      return Math.round(value * week);
    default:
      return Math.round(value * year);
  }
};
const normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
const checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
var jwtPayload = (protectedHeader, encodedPayload, options = {}) => {
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
  }
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch (_a) {
  }
  if (!isObject(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { issuer } = options;
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
  }
  const { subject } = options;
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
  }
  const { audience } = options;
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch(currentDate || new Date());
  if (payload.iat !== void 0 || options.maxTokenAge) {
    if (typeof payload.iat !== "number") {
      throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
    }
    if (payload.exp === void 0 && payload.iat > now + tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
    }
  }
  if (payload.nbf !== void 0) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
    }
  }
  if (payload.exp !== void 0) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
    }
  }
  if (options.maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof options.maxTokenAge === "number" ? options.maxTokenAge : secs(options.maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
    }
  }
  return payload;
};
async function jwtVerify(jwt, key, options) {
  var _a;
  const verified = await compactVerify(jwt, key, options);
  if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwtPayload(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return __spreadProps(__spreadValues({}, result), { key: verified.key });
  }
  return result;
}
function createSSO(config, fetch2 = window.fetch) {
  return new EveSSOAuth(config, fetch2);
}
const BASE_URI = "https://login.eveonline.com/";
const AUTHORIZE_PATH = "/v2/oauth/authorize";
const TOKEN_PATH = "/v2/oauth/token";
const REVOKE_PATH = "/v2/oauth/revoke";
const JWKS_URL = "https://login.eveonline.com/oauth/jwks";
class EveSSOAuth {
  constructor(config, fetchParam = window.fetch) {
    __publicField$1(this, "config");
    __publicField$1(this, "publicKey");
    __publicField$1(this, "fetch");
    this.fetch = fetchParam.bind(window);
    this.config = config;
  }
  async generateState() {
    return await getRandomString(8);
  }
  async generateCodeVerifier() {
    return await getRandomString(64);
  }
  async generateCodeChallenge(codeVerifier) {
    return await createHash(codeVerifier);
  }
  async _getJWKKeyData() {
    try {
      const response = await fetch(JWKS_URL);
      return await response.json();
    } catch (error) {
      console.log("There was an error retreiving JWK data", error);
    }
  }
  async getPublicKey() {
    if (this.publicKey === void 0) {
      try {
        const jwks = await this._getJWKKeyData();
        if (jwks !== null) {
          const key = jwks.keys.find((x) => x.alg === "RS256");
          this.publicKey = await importJWK(key);
          return this.publicKey;
        } else {
          throw new Error("There was a problem obtaining public key");
        }
      } catch (error) {
        console.log("There was an error retreiving the public key:", error);
      }
    }
    return this.publicKey;
  }
  async getUri(scope = []) {
    const state = await this.generateState();
    const codeVerifier = await this.generateCodeVerifier();
    const codeChallenge = await this.generateCodeChallenge(codeVerifier);
    const url = new URL(AUTHORIZE_PATH, BASE_URI);
    url.searchParams.append("response_type", "code");
    url.searchParams.append("redirect_uri", this.config.redirectUri);
    url.searchParams.append("client_id", this.config.clientId);
    url.searchParams.append("code_challenge", codeChallenge);
    url.searchParams.append("code_challenge_method", "S256");
    url.searchParams.append("scope", scope.join(" "));
    url.searchParams.append("state", state);
    return {
      uri: url.toString(),
      state,
      codeVerifier
    };
  }
  async verifyToken(token) {
    const publicKey = await this.getPublicKey();
    const { payload } = await jwtVerify(token.access_token, publicKey, {
      issuer: "login.eveonline.com"
    });
    token.payload = payload;
    return token;
  }
  async _fetchToken(url, init) {
    return await this.fetch(url, init);
  }
  async getAccessToken(code, codeVerifier) {
    try {
      const form = new URLSearchParams();
      form.append("grant_type", "authorization_code");
      form.append("code", code);
      form.append("client_id", this.config.clientId);
      form.append("code_verifier", codeVerifier);
      const url = new URL(TOKEN_PATH, BASE_URI).toString();
      const response = await this._fetchToken(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Host: "login.eveonline.com"
        },
        body: form
      });
      const token = await this.verifyToken(await response.json());
      return token;
    } catch (error) {
      console.log("There was an error retreiving the token:", error);
      throw error;
    }
  }
  async refreshToken(refreshToken, scopes) {
    try {
      const form = new URLSearchParams();
      form.append("grant_type", "refresh_token");
      form.append("refresh_token", refreshToken);
      form.append("client_id", this.config.clientId);
      if (scopes !== void 0)
        form.append("scope", scopes.join(" "));
      const url = new URL(TOKEN_PATH, BASE_URI).toString();
      const response = await this._fetchToken(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Host: "login.eveonline.com"
        },
        body: form
      });
      const token = await this.verifyToken(await response.json());
      return token;
    } catch (error) {
      console.log("There was an error retreiving the token:", error);
      throw error;
    }
  }
  async revokeRefreshToken(refreshToken) {
    try {
      const form = new URLSearchParams();
      form.append("token_type_hint", "refresh_token");
      form.append("token", refreshToken);
      form.append("client_id", this.config.clientId);
      const url = new URL(REVOKE_PATH, BASE_URI).toString();
      const headers = new Headers();
      headers.set("Content-Type", "application/x-www-form-urlencoded");
      headers.set("Host", "login.eveonline.com");
      await this._fetchToken(url, {
        method: "POST",
        headers,
        body: form
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}

const sso = createSSO({
    clientId: 'd3639f9146214ab3b97010e558042c76',
    redirectUri: 'http://localhost:3000/'
});
const scopes = 'esi-skills.read_skills.v1 esi-skills.read_skillqueue.v1 esi-clones.read_implants.v1'.split(' ');

const initLoginState = async () => {
    
    document.querySelector('.login').addEventListener('click', async (event) => {
        event.preventDefault();
        clearData('codeVerifier');
        clearData('token');
        console.log('scopes', scopes);
        const ssoUri = await sso.getUri(scopes);
        console.log('ssoUri', ssoUri);
        saveData('codeVerifier', ssoUri.codeVerifier);
        console.log('ssoUri', scopes, ssoUri);
        window.location.assign(ssoUri.uri);
    });

    const data = loadData();
    console.log('data', data);
    if (data.token) {
        // console.log('Successfully logged in')
        return true
    } else if (data.codeVerifier) {
        console.log('Code verifier set, awaiting server response');
        const urlParams = new URLSearchParams(window.location.search);
        const code = urlParams.get('code');
        const state = urlParams.get('state');
        if (code && state) {
            console.log('code', code, 'state', state);

            const token = await sso.getAccessToken(code, data.codeVerifier);
            console.log('token', token);
            saveData('token', token);
            clearData('codeVerifier');

            window.location.assign(window.location.href.split('?')[0]); // Strip the url parameters
        } else {
            // If this happens, we need to clear the 
            clearData('codeVerifier');
            window.location.assign(window.location.href.split('?')[0]);
        }
        console.log('No code or state in the url, SSO return unsuccessful');
    } else {
        console.log('No login state set');
        
    }
    
    return false
};
const refreshToken = async () => {
    const data = loadData();
    console.log('TODO refreshToken', data.token.refresh_token);
    const newToken = await sso.refreshToken(data.token.refresh_token);
    console.log('newToken', newToken);
    saveData('token', newToken);
    // alert('refresh')
    window.location.assign(window.location.href.split('?')[0]);
};

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ContentType;
(function(ContentType2) {
  ContentType2["Json"] = "application/json";
  ContentType2["FormData"] = "multipart/form-data";
  ContentType2["UrlEncoded"] = "application/x-www-form-urlencoded";
})(ContentType || (ContentType = {}));
class HttpClient {
  constructor(apiConfig = {}) {
    __publicField(this, "baseUrl", "https://esi.evetech.net/latest");
    __publicField(this, "securityData", null);
    __publicField(this, "securityWorker");
    __publicField(this, "abortControllers", /* @__PURE__ */ new Map());
    __publicField(this, "customFetch", (...fetchParams) => fetch(...fetchParams));
    __publicField(this, "baseApiParams", {
      credentials: "same-origin",
      headers: {},
      redirect: "follow",
      referrerPolicy: "no-referrer"
    });
    __publicField(this, "setSecurityData", (data) => {
      this.securityData = data;
    });
    __publicField(this, "contentFormatters", {
      [ContentType.Json]: (input) => input !== null && (typeof input === "object" || typeof input === "string") ? JSON.stringify(input) : input,
      [ContentType.FormData]: (input) => Object.keys(input || {}).reduce((formData, key) => {
        const property = input[key];
        formData.append(key, property instanceof Blob ? property : typeof property === "object" && property !== null ? JSON.stringify(property) : `${property}`);
        return formData;
      }, new FormData()),
      [ContentType.UrlEncoded]: (input) => this.toQueryString(input)
    });
    __publicField(this, "createAbortSignal", (cancelToken) => {
      if (this.abortControllers.has(cancelToken)) {
        const abortController2 = this.abortControllers.get(cancelToken);
        if (abortController2) {
          return abortController2.signal;
        }
        return void 0;
      }
      const abortController = new AbortController();
      this.abortControllers.set(cancelToken, abortController);
      return abortController.signal;
    });
    __publicField(this, "abortRequest", (cancelToken) => {
      const abortController = this.abortControllers.get(cancelToken);
      if (abortController) {
        abortController.abort();
        this.abortControllers.delete(cancelToken);
      }
    });
    __publicField(this, "request", async ({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params }) => {
      const secureParams = (typeof secure === "boolean" ? secure : this.baseApiParams.secure) && this.securityWorker && await this.securityWorker(this.securityData) || {};
      const requestParams = this.mergeRequestParams(params, secureParams);
      const queryString = query && this.toQueryString(query);
      const payloadFormatter = this.contentFormatters[type || ContentType.Json];
      const responseFormat = format || requestParams.format;
      return this.customFetch(`${baseUrl || this.baseUrl || ""}${path}${queryString ? `?${queryString}` : ""}`, {
        ...requestParams,
        headers: {
          ...type && type !== ContentType.FormData ? { "Content-Type": type } : {},
          ...requestParams.headers || {}
        },
        signal: cancelToken ? this.createAbortSignal(cancelToken) : void 0,
        body: typeof body === "undefined" || body === null ? null : payloadFormatter(body)
      }).then(async (response) => {
        const r = response;
        r.data = null;
        r.error = null;
        const data = !responseFormat ? r : await response[responseFormat]().then((data2) => {
          if (r.ok) {
            r.data = data2;
          } else {
            r.error = data2;
          }
          return r;
        }).catch((e) => {
          r.error = e;
          return r;
        });
        if (cancelToken) {
          this.abortControllers.delete(cancelToken);
        }
        if (!response.ok)
          throw data;
        return data;
      });
    });
    Object.assign(this, apiConfig);
  }
  encodeQueryParam(key, value) {
    const encodedKey = encodeURIComponent(key);
    return `${encodedKey}=${encodeURIComponent(typeof value === "number" ? value : `${value}`)}`;
  }
  addQueryParam(query, key) {
    return this.encodeQueryParam(key, query[key]);
  }
  addArrayQueryParam(query, key) {
    const value = query[key];
    return value.map((v) => this.encodeQueryParam(key, v)).join("&");
  }
  toQueryString(rawQuery) {
    const query = rawQuery || {};
    const keys = Object.keys(query).filter((key) => typeof query[key] !== "undefined");
    return keys.map((key) => Array.isArray(query[key]) ? this.addArrayQueryParam(query, key) : this.addQueryParam(query, key)).join("&");
  }
  addQueryParams(rawQuery) {
    const queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }
  mergeRequestParams(params1, params2) {
    return {
      ...this.baseApiParams,
      ...params1,
      ...params2 || {},
      headers: {
        ...this.baseApiParams.headers || {},
        ...params1.headers || {},
        ...params2 && params2.headers || {}
      }
    };
  }
}
class Api extends HttpClient {
  constructor() {
    super(...arguments);
    __publicField(this, "alliances", {
      getAlliances: (query, params = {}) => this.request({
        path: `/alliances/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getAlliancesAllianceId: (allianceId, query, params = {}) => this.request({
        path: `/alliances/${allianceId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getAlliancesAllianceIdContacts: (allianceId, query, params = {}) => this.request({
        path: `/alliances/${allianceId}/contacts/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getAlliancesAllianceIdContactsLabels: (allianceId, query, params = {}) => this.request({
        path: `/alliances/${allianceId}/contacts/labels/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getAlliancesAllianceIdCorporations: (allianceId, query, params = {}) => this.request({
        path: `/alliances/${allianceId}/corporations/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getAlliancesAllianceIdIcons: (allianceId, query, params = {}) => this.request({
        path: `/alliances/${allianceId}/icons/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "characters", {
      postCharactersAffiliation: (characters, query, params = {}) => this.request({
        path: `/characters/affiliation/`,
        method: "POST",
        query,
        body: characters,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getCharactersCharacterId: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdAgentsResearch: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/agents_research/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdAssets: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/assets/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdAssetsLocations: (characterId, item_ids, query, params = {}) => this.request({
        path: `/characters/${characterId}/assets/locations/`,
        method: "POST",
        query,
        body: item_ids,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdAssetsNames: (characterId, item_ids, query, params = {}) => this.request({
        path: `/characters/${characterId}/assets/names/`,
        method: "POST",
        query,
        body: item_ids,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdAttributes: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/attributes/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdBlueprints: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/blueprints/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdBookmarks: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/bookmarks/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdBookmarksFolders: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/bookmarks/folders/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdCalendar: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/calendar/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdCalendarEventId: (characterId, eventId, query, params = {}) => this.request({
        path: `/characters/${characterId}/calendar/${eventId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      putCharactersCharacterIdCalendarEventId: (characterId, eventId, response, query, params = {}) => this.request({
        path: `/characters/${characterId}/calendar/${eventId}/`,
        method: "PUT",
        query,
        body: response,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      getCharactersCharacterIdCalendarEventIdAttendees: (characterId, eventId, query, params = {}) => this.request({
        path: `/characters/${characterId}/calendar/${eventId}/attendees/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdClones: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/clones/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      deleteCharactersCharacterIdContacts: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/contacts/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      getCharactersCharacterIdContacts: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/contacts/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdContacts: (characterId, query, contact_ids, params = {}) => this.request({
        path: `/characters/${characterId}/contacts/`,
        method: "POST",
        query,
        body: contact_ids,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      putCharactersCharacterIdContacts: (characterId, query, contact_ids, params = {}) => this.request({
        path: `/characters/${characterId}/contacts/`,
        method: "PUT",
        query,
        body: contact_ids,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      getCharactersCharacterIdContactsLabels: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/contacts/labels/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdContracts: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/contracts/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdContractsContractIdBids: (characterId, contractId, query, params = {}) => this.request({
        path: `/characters/${characterId}/contracts/${contractId}/bids/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdContractsContractIdItems: (characterId, contractId, query, params = {}) => this.request({
        path: `/characters/${characterId}/contracts/${contractId}/items/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdCorporationhistory: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/corporationhistory/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdCspa: (characterId, characters, query, params = {}) => this.request({
        path: `/characters/${characterId}/cspa/`,
        method: "POST",
        query,
        body: characters,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdFatigue: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/fatigue/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdFittings: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/fittings/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdFittings: (characterId, fitting, query, params = {}) => this.request({
        path: `/characters/${characterId}/fittings/`,
        method: "POST",
        query,
        body: fitting,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      deleteCharactersCharacterIdFittingsFittingId: (characterId, fittingId, query, params = {}) => this.request({
        path: `/characters/${characterId}/fittings/${fittingId}/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      getCharactersCharacterIdFleet: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/fleet/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdFwStats: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/fw/stats/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdImplants: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/implants/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdIndustryJobs: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/industry/jobs/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdKillmailsRecent: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/killmails/recent/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdLocation: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/location/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdLoyaltyPoints: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/loyalty/points/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdMail: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdMail: (characterId, mail, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/`,
        method: "POST",
        query,
        body: mail,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdMailLabels: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/labels/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdMailLabels: (characterId, label, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/labels/`,
        method: "POST",
        query,
        body: label,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      deleteCharactersCharacterIdMailLabelsLabelId: (characterId, labelId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/labels/${labelId}/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      getCharactersCharacterIdMailLists: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/lists/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      deleteCharactersCharacterIdMailMailId: (characterId, mailId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/${mailId}/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      getCharactersCharacterIdMailMailId: (characterId, mailId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/${mailId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      putCharactersCharacterIdMailMailId: (characterId, mailId, contents, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/${mailId}/`,
        method: "PUT",
        query,
        body: contents,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      getCharactersCharacterIdMedals: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/medals/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdMining: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mining/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdNotifications: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/notifications/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdNotificationsContacts: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/notifications/contacts/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdOnline: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/online/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdOpportunities: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/opportunities/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdOrders: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/orders/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdOrdersHistory: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/orders/history/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdPlanets: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/planets/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdPlanetsPlanetId: (characterId, planetId, query, params = {}) => this.request({
        path: `/characters/${characterId}/planets/${planetId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdPortrait: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/portrait/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdRoles: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/roles/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdSearch: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/search/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdShip: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/ship/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdSkillqueue: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/skillqueue/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdSkills: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/skills/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdStandings: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/standings/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdTitles: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/titles/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdWallet: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/wallet/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdWalletJournal: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/wallet/journal/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdWalletTransactions: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/wallet/transactions/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      })
    });
    __publicField(this, "contracts", {
      getContractsPublicBidsContractId: (contractId, query, params = {}) => this.request({
        path: `/contracts/public/bids/${contractId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getContractsPublicItemsContractId: (contractId, query, params = {}) => this.request({
        path: `/contracts/public/items/${contractId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getContractsPublicRegionId: (regionId, query, params = {}) => this.request({
        path: `/contracts/public/${regionId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "corporation", {
      getCorporationCorporationIdMiningExtractions: (corporationId, query, params = {}) => this.request({
        path: `/corporation/${corporationId}/mining/extractions/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationCorporationIdMiningObservers: (corporationId, query, params = {}) => this.request({
        path: `/corporation/${corporationId}/mining/observers/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationCorporationIdMiningObserversObserverId: (corporationId, observerId, query, params = {}) => this.request({
        path: `/corporation/${corporationId}/mining/observers/${observerId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      })
    });
    __publicField(this, "corporations", {
      getCorporationsNpccorps: (query, params = {}) => this.request({
        path: `/corporations/npccorps/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getCorporationsCorporationId: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdAlliancehistory: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/alliancehistory/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdAssets: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/assets/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postCorporationsCorporationIdAssetsLocations: (corporationId, item_ids, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/assets/locations/`,
        method: "POST",
        query,
        body: item_ids,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      postCorporationsCorporationIdAssetsNames: (corporationId, item_ids, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/assets/names/`,
        method: "POST",
        query,
        body: item_ids,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdBlueprints: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/blueprints/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdBookmarks: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/bookmarks/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdBookmarksFolders: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/bookmarks/folders/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdContacts: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/contacts/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdContactsLabels: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/contacts/labels/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdContainersLogs: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/containers/logs/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdContracts: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/contracts/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdContractsContractIdBids: (contractId, corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/contracts/${contractId}/bids/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdContractsContractIdItems: (contractId, corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/contracts/${contractId}/items/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdCustomsOffices: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/customs_offices/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdDivisions: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/divisions/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdFacilities: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/facilities/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdFwStats: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/fw/stats/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdIcons: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/icons/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdIndustryJobs: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/industry/jobs/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdKillmailsRecent: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/killmails/recent/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdMedals: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/medals/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdMedalsIssued: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/medals/issued/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdMembers: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/members/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdMembersLimit: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/members/limit/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdMembersTitles: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/members/titles/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdMembertracking: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/membertracking/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdOrders: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/orders/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdOrdersHistory: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/orders/history/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdRoles: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/roles/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdRolesHistory: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/roles/history/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdShareholders: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/shareholders/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdStandings: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/standings/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdStarbases: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/starbases/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdStarbasesStarbaseId: (corporationId, starbaseId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/starbases/${starbaseId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdStructures: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/structures/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdTitles: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/titles/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdWallets: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/wallets/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdWalletsDivisionJournal: (corporationId, division, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/wallets/${division}/journal/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdWalletsDivisionTransactions: (corporationId, division, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/wallets/${division}/transactions/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      })
    });
    __publicField(this, "dogma", {
      getDogmaAttributes: (query, params = {}) => this.request({
        path: `/dogma/attributes/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getDogmaAttributesAttributeId: (attributeId, query, params = {}) => this.request({
        path: `/dogma/attributes/${attributeId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getDogmaDynamicItemsTypeIdItemId: (itemId, typeId, query, params = {}) => this.request({
        path: `/dogma/dynamic/items/${typeId}/${itemId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getDogmaEffects: (query, params = {}) => this.request({
        path: `/dogma/effects/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getDogmaEffectsEffectId: (effectId, query, params = {}) => this.request({
        path: `/dogma/effects/${effectId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "fleets", {
      getFleetsFleetId: (fleetId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      putFleetsFleetId: (fleetId, new_settings, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/`,
        method: "PUT",
        query,
        body: new_settings,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      getFleetsFleetIdMembers: (fleetId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/members/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postFleetsFleetIdMembers: (fleetId, invitation, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/members/`,
        method: "POST",
        query,
        body: invitation,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      deleteFleetsFleetIdMembersMemberId: (fleetId, memberId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/members/${memberId}/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      putFleetsFleetIdMembersMemberId: (fleetId, memberId, movement, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/members/${memberId}/`,
        method: "PUT",
        query,
        body: movement,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      deleteFleetsFleetIdSquadsSquadId: (fleetId, squadId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/squads/${squadId}/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      putFleetsFleetIdSquadsSquadId: (fleetId, squadId, naming, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/squads/${squadId}/`,
        method: "PUT",
        query,
        body: naming,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      getFleetsFleetIdWings: (fleetId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/wings/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postFleetsFleetIdWings: (fleetId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/wings/`,
        method: "POST",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      deleteFleetsFleetIdWingsWingId: (fleetId, wingId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/wings/${wingId}/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      putFleetsFleetIdWingsWingId: (fleetId, wingId, naming, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/wings/${wingId}/`,
        method: "PUT",
        query,
        body: naming,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      postFleetsFleetIdWingsWingIdSquads: (fleetId, wingId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/wings/${wingId}/squads/`,
        method: "POST",
        query,
        secure: true,
        format: "json",
        ...params
      })
    });
    __publicField(this, "fw", {
      getFwLeaderboards: (query, params = {}) => this.request({
        path: `/fw/leaderboards/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getFwLeaderboardsCharacters: (query, params = {}) => this.request({
        path: `/fw/leaderboards/characters/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getFwLeaderboardsCorporations: (query, params = {}) => this.request({
        path: `/fw/leaderboards/corporations/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getFwStats: (query, params = {}) => this.request({
        path: `/fw/stats/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getFwSystems: (query, params = {}) => this.request({
        path: `/fw/systems/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getFwWars: (query, params = {}) => this.request({
        path: `/fw/wars/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "incursions", {
      getIncursions: (query, params = {}) => this.request({
        path: `/incursions/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "industry", {
      getIndustryFacilities: (query, params = {}) => this.request({
        path: `/industry/facilities/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getIndustrySystems: (query, params = {}) => this.request({
        path: `/industry/systems/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "insurance", {
      getInsurancePrices: (query, params = {}) => this.request({
        path: `/insurance/prices/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "killmails", {
      getKillmailsKillmailIdKillmailHash: (killmailHash, killmailId, query, params = {}) => this.request({
        path: `/killmails/${killmailId}/${killmailHash}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "loyalty", {
      getLoyaltyStoresCorporationIdOffers: (corporationId, query, params = {}) => this.request({
        path: `/loyalty/stores/${corporationId}/offers/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "markets", {
      getMarketsGroups: (query, params = {}) => this.request({
        path: `/markets/groups/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getMarketsGroupsMarketGroupId: (marketGroupId, query, params = {}) => this.request({
        path: `/markets/groups/${marketGroupId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getMarketsPrices: (query, params = {}) => this.request({
        path: `/markets/prices/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getMarketsStructuresStructureId: (structureId, query, params = {}) => this.request({
        path: `/markets/structures/${structureId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getMarketsRegionIdHistory: (regionId, query, params = {}) => this.request({
        path: `/markets/${regionId}/history/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getMarketsRegionIdOrders: (regionId, query, params = {}) => this.request({
        path: `/markets/${regionId}/orders/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getMarketsRegionIdTypes: (regionId, query, params = {}) => this.request({
        path: `/markets/${regionId}/types/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "opportunities", {
      getOpportunitiesGroups: (query, params = {}) => this.request({
        path: `/opportunities/groups/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getOpportunitiesGroupsGroupId: (groupId, query, params = {}) => this.request({
        path: `/opportunities/groups/${groupId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getOpportunitiesTasks: (query, params = {}) => this.request({
        path: `/opportunities/tasks/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getOpportunitiesTasksTaskId: (taskId, query, params = {}) => this.request({
        path: `/opportunities/tasks/${taskId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "route", {
      getRouteOriginDestination: (destination, origin, query, params = {}) => this.request({
        path: `/route/${origin}/${destination}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "search", {
      getSearch: (query, params = {}) => this.request({
        path: `/search/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "sovereignty", {
      getSovereigntyCampaigns: (query, params = {}) => this.request({
        path: `/sovereignty/campaigns/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getSovereigntyMap: (query, params = {}) => this.request({
        path: `/sovereignty/map/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getSovereigntyStructures: (query, params = {}) => this.request({
        path: `/sovereignty/structures/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "status", {
      getStatus: (query, params = {}) => this.request({
        path: `/status/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "ui", {
      postUiAutopilotWaypoint: (query, params = {}) => this.request({
        path: `/ui/autopilot/waypoint/`,
        method: "POST",
        query,
        secure: true,
        ...params
      }),
      postUiOpenwindowContract: (query, params = {}) => this.request({
        path: `/ui/openwindow/contract/`,
        method: "POST",
        query,
        secure: true,
        ...params
      }),
      postUiOpenwindowInformation: (query, params = {}) => this.request({
        path: `/ui/openwindow/information/`,
        method: "POST",
        query,
        secure: true,
        ...params
      }),
      postUiOpenwindowMarketdetails: (query, params = {}) => this.request({
        path: `/ui/openwindow/marketdetails/`,
        method: "POST",
        query,
        secure: true,
        ...params
      }),
      postUiOpenwindowNewmail: (new_mail, query, params = {}) => this.request({
        path: `/ui/openwindow/newmail/`,
        method: "POST",
        query,
        body: new_mail,
        secure: true,
        type: ContentType.Json,
        ...params
      })
    });
    __publicField(this, "universe", {
      getUniverseAncestries: (query, params = {}) => this.request({
        path: `/universe/ancestries/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseAsteroidBeltsAsteroidBeltId: (asteroidBeltId, query, params = {}) => this.request({
        path: `/universe/asteroid_belts/${asteroidBeltId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseBloodlines: (query, params = {}) => this.request({
        path: `/universe/bloodlines/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseCategories: (query, params = {}) => this.request({
        path: `/universe/categories/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseCategoriesCategoryId: (categoryId, query, params = {}) => this.request({
        path: `/universe/categories/${categoryId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseConstellations: (query, params = {}) => this.request({
        path: `/universe/constellations/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseConstellationsConstellationId: (constellationId, query, params = {}) => this.request({
        path: `/universe/constellations/${constellationId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseFactions: (query, params = {}) => this.request({
        path: `/universe/factions/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseGraphics: (query, params = {}) => this.request({
        path: `/universe/graphics/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseGraphicsGraphicId: (graphicId, query, params = {}) => this.request({
        path: `/universe/graphics/${graphicId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseGroups: (query, params = {}) => this.request({
        path: `/universe/groups/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseGroupsGroupId: (groupId, query, params = {}) => this.request({
        path: `/universe/groups/${groupId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      postUniverseIds: (names, query, params = {}) => this.request({
        path: `/universe/ids/`,
        method: "POST",
        query,
        body: names,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getUniverseMoonsMoonId: (moonId, query, params = {}) => this.request({
        path: `/universe/moons/${moonId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      postUniverseNames: (ids, query, params = {}) => this.request({
        path: `/universe/names/`,
        method: "POST",
        query,
        body: ids,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getUniversePlanetsPlanetId: (planetId, query, params = {}) => this.request({
        path: `/universe/planets/${planetId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseRaces: (query, params = {}) => this.request({
        path: `/universe/races/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseRegions: (query, params = {}) => this.request({
        path: `/universe/regions/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseRegionsRegionId: (regionId, query, params = {}) => this.request({
        path: `/universe/regions/${regionId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseSchematicsSchematicId: (schematicId, query, params = {}) => this.request({
        path: `/universe/schematics/${schematicId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseStargatesStargateId: (stargateId, query, params = {}) => this.request({
        path: `/universe/stargates/${stargateId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseStarsStarId: (starId, query, params = {}) => this.request({
        path: `/universe/stars/${starId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseStationsStationId: (stationId, query, params = {}) => this.request({
        path: `/universe/stations/${stationId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseStructures: (query, params = {}) => this.request({
        path: `/universe/structures/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseStructuresStructureId: (structureId, query, params = {}) => this.request({
        path: `/universe/structures/${structureId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getUniverseSystemJumps: (query, params = {}) => this.request({
        path: `/universe/system_jumps/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseSystemKills: (query, params = {}) => this.request({
        path: `/universe/system_kills/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseSystems: (query, params = {}) => this.request({
        path: `/universe/systems/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseSystemsSystemId: (systemId, query, params = {}) => this.request({
        path: `/universe/systems/${systemId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseTypes: (query, params = {}) => this.request({
        path: `/universe/types/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseTypesTypeId: (typeId, query, params = {}) => this.request({
        path: `/universe/types/${typeId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "wars", {
      getWars: (query, params = {}) => this.request({
        path: `/wars/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getWarsWarId: (warId, query, params = {}) => this.request({
        path: `/wars/${warId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getWarsWarIdKillmails: (warId, query, params = {}) => this.request({
        path: `/wars/${warId}/killmails/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
  }
}

const esi = new Api();

const formatTime = (totalMinutes, full) => {
    const minutesPerDay = 24 * 60;
    const minutesPerHour = 60;
    const days = Math.floor(totalMinutes / minutesPerDay);
    const remainingMinutes = totalMinutes % minutesPerDay;
    const hours = Math.floor(remainingMinutes / minutesPerHour);
    const minutes = Math.ceil(remainingMinutes % minutesPerHour);
  
    if(full) return `${days}d ${hours}h ${minutes}m`
    if(days < 0 && hours < 0) return `${minutes}m`
    if(days < 0 && hours > 0) return `${hours}h ${minutes}m`
    if(days > 0 && minutes > 0) return `${days}d ${hours+1}h`
    return `${days}d ${hours}h`
  };
  
const calculateSPPerMinute = (primary, secondary) => {
    return primary + 0.5 * secondary;
  };

  
const calculateSkillTrainingTime = (skillFromQueue, skill, attributes) => {
    // console.log('calculateSkillTrainingTime', skillFromQueue, skill, attributes)
    const { primary, secondary } = skill;
    // console.log('calculateSkillTrainingTime', primary, secondary)
    const spPerMinute = calculateSPPerMinute(attributes[primary].total, attributes[secondary].total);
    // console.log('spPerMinute', attributes[primary].total, attributes[secondary].total, spPerMinute)
    const timeRequiredInMinutes = skillFromQueue.requiredSP / spPerMinute;
    return timeRequiredInMinutes
};
const attList = ['charisma','intelligence','memory','perception','willpower'];
const implantAttributeMap = {
    175: "charisma",
    176: "intelligence",
    177: "memory",
    178: "perception",
    179: "willpower"
};
const skillTypeAttributeMap = {
    164: "charisma",
    165: "intelligence",
    166: "memory",
    167: "perception",
    168: "willpower"
};
const skillAttributes = {
    180: "primary",
    181: "secondary",
    275: "multiplier"
};
const getSkillsData = async () => {
    const data = loadData();
    // console.log('data', data)
    const characterId = data.token.payload.sub.replace('CHARACTER:EVE:','');
    const character = {
        characterId,
        name: data.token.payload.name
    };
    

    try {
        const skills = (await esi.characters.getCharactersCharacterIdSkills(characterId, {token: data.token.access_token})).data;
        // console.log('skills', skills)

        const skillQueue = {
            skills: (await esi.characters.getCharactersCharacterIdSkillqueue(characterId, {token: data.token.access_token})).data,
            total: 0,
            totalString: 0
        };
        // console.log('skillQueue', skillQueue)

        const implantModifiers = Object.fromEntries(attList.map(attribute => [attribute, 0]));
        
        

        const implants = await Promise.all((await esi.characters.getCharactersCharacterIdImplants(characterId, {token: data.token.access_token})).data.map(async typeId => {
            const type = (await esi.universe.getUniverseTypesTypeId(typeId, {token: data.token.access_token})).data;
            // console.log('implant', type)
            if (type) {
                type.dogma_attributes.forEach((attribute) => {
                    const key = implantAttributeMap[attribute.attribute_id];
                    if (key) {
                        implantModifiers[key] += attribute.value;
                    }
                });
            }
            return typeId
        })
        );
        // console.log('implantModifiers', implantModifiers)
        // console.log('implants', implants)

        const attributes = (await esi.characters.getCharactersCharacterIdAttributes(characterId, {token: data.token.access_token})).data;
        for (const att of attList) {
            const base = 17;
            const implants = implantModifiers[att];
            const remap = attributes[att] - 17 - implantModifiers[att];
            const total = base + implants + remap;
            // TODO Boosters?!
            attributes[att] = {base, implants, remap, total };    
        }
        
        // console.log('attributes', attributes)

        

        const categories = (await esi.universe.getUniverseCategoriesCategoryId(16, {token: data.token.access_token})).data;
        
        categories.groups = await Promise.all(categories.groups.map(async groupId => {
            const group = (await esi.universe.getUniverseGroupsGroupId(groupId, {token: data.token.access_token})).data;
            group.types = await Promise.all(group.types.map(async typeId => {
                const type = (await esi.universe.getUniverseTypesTypeId(typeId, {token: data.token.access_token})).data;
                const trainedSkill = skills.skills.find(s => s.skill_id === type.type_id);
                if (trainedSkill) {
                    type.trainedSkillLevel = trainedSkill.trained_skill_level;
                    type.skillpoints = trainedSkill.skillpoints_in_skill;
                } else {
                    type.trainedSkillLevel = 0;
                    type.skillpoints = 0;
                }
                const queuedSkill = skillQueue.skills.find(s => s.skill_id === type.type_id);
                if (queuedSkill) {
                    type.queuedSkillLevel = queuedSkill.finished_level;
                } else {
                    type.queuedSkillLevel = 0;
                }
               
              
              type.dogma_attributes.forEach((attribute) => {
                const key = skillAttributes[attribute.attribute_id];
                if (key) {
                  type[key] = key === 'multiplier' ? attribute.value : skillTypeAttributeMap[attribute.value];
                }
              });
              
                
                return type
            }));

            group.types = group.types.filter(g => g.published === true);
            group.types.sort((a,b) => a.name.localeCompare(b.name));
            return group
        }));
        categories.groups = categories.groups.filter(g => g.published === true);
        categories.groups.sort((a,b) => a.name.localeCompare(b.name));

        const flatCategories = categories.groups.flatMap(group => group.types);

        skillQueue.skills.forEach(s => {
            const skill = flatCategories.find(f => f.type_id === s.skill_id);
            if (skill) {
                s.name = skill.name;
                s.requiredSP = s.level_end_sp - Math.max(s.training_start_sp,s.level_start_sp);
                s.trainedSkillLevel = skill.trainedSkillLevel;
                s.trainingTime = calculateSkillTrainingTime(s, skill, attributes);
                s.trainingTimeString = formatTime(s.trainingTime);
                s.multiplier = skill.multiplier;
                s.primary = skill.primary;
                s.secondary = skill.secondary;
                skillQueue.total += s.trainingTime;
            }
        });
        skillQueue.totalString = formatTime(skillQueue.total, true);
        // console.log('categories', categories)
        // console.log('flatCategories', flatCategories)
        return {skills, skillQueue, attributes, implants, categories, flatCategories, character}
    } catch (error) {
        console.error('error', error.error);
        if(error && error.error && error.error.error && error.error.error === 'token is expired') {
            await refreshToken();
            // TODO - Relaunch this method
            // return getSkillsData()
        }
    }

};

const groupByPrimaryAndSecondary = (data, retainList) => {
    const groupedData = data.reduce((acc, obj) => {
      const key = obj.primary + '-' + obj.secondary;
      if (!acc[key]) {
        acc[key] = [];
      }
      acc[key].push(obj);
      return acc
    }, {});
    const resultArray = Object.entries(groupedData).map(([key, dataList]) =>  {
        
        const obj = {
        // key,
        primary: key.split('-')[0],
        secondary: key.split('-')[1],
        // dataList,
        requiredSP: dataList.map(d => d.requiredSP).reduce((a, v) => a + v, 0)
      };
      if(retainList) obj.dataList = dataList;
      return obj
    });
    
    return resultArray;
  };

const getSortingOrders = (arr) => {
    const result = [];
  
    function permute(arr, start = 0) {
      if (start === arr.length) {
        result.push(arr.slice());
        return;
      }
  
      for (let i = start; i < arr.length; i++) {
        [arr[start], arr[i]] = [arr[i], arr[start]]; // Swap elements
        permute(arr, start + 1);
        [arr[start], arr[i]] = [arr[i], arr[start]]; // Backtrack (undo the swap)
      }
    }
  
    permute(arr);
    return [...new Set(result.map(JSON.stringify))].map(JSON.parse);
};
const getPopularCombinations = (targetSum, maxCount, attributes) => {
    return [
        {charisma: 10, intelligence: 4},
        {charisma: 10, memory: 4},
        {charisma: 10, perception: 4},
        {charisma: 10, willpower: 4},

        {intelligence: 10, charisma: 4},
        {intelligence: 10, memory: 4},
        {intelligence: 10, perception: 4},
        {intelligence: 10, willpower: 4},

        {memory: 10, charisma: 4},
        {memory: 10, intelligence: 4},
        {memory: 10, perception: 4},
        {memory: 10, willpower: 4},

        {perception: 10, charisma: 4},
        {perception: 10, intelligence: 4},
        {perception: 10, memory: 4},
        {perception: 10, willpower: 4},

        {willpower: 10, charisma: 4},
        {willpower: 10, intelligence: 4},
        {willpower: 10, memory: 4},
        {willpower: 10, perception: 4},

        {charisma: 2, intelligence: 4, memory: 4, perception: 2, willpower: 2},
        {charisma: 2, intelligence: 2, memory: 2, perception: 4, willpower: 4}
        
    ]
};
const explodeRemapsOnce = (a) => {
    const b = [];
    for (aa of a) {
        const remapIndexes = aa.map((v,i) => (v.remap && Array.isArray(v.remap) ? i: null)).filter(i => i !==null);
        // console.log('aa',aa, remapIndexes)
        if(remapIndexes.length > 0) {
            const r = remapIndexes[0];
            // console.log('r', r, aa[r].remap)
            for (r2 of aa[r].remap) {
                const newItem = JSON.parse(JSON.stringify(aa));
                newItem[r].remap = r2;
                // console.log('  r2', r2, newItem)
                b.push(newItem);
            }
        } else {
            b.push(aa);
        }
    }
    return b
};

const explodeRemaps = (data, remapCount) => {
    let result = explodeRemapsOnce(data);
    for (let r = 1; r < remapCount; r++) {
        // console.log('sssss r', r)
        result = explodeRemapsOnce(result);
    }
    return result
};

// const allRemapCombinations = getAllCombinations(14,10, attList)
const allRemapCombinations = getPopularCombinations();
const allRemapCombinationsIndexList = Array.from({ length: allRemapCombinations.length }, (_, i) => i);
// const allRemapCombinationsIndexList = Array.from({ length: 11 }, (_, i) => i)

const calculateIndividualTimesForFastestPermutation = (startingAttributes, onePerm) => {
    let attributes = JSON.parse(JSON.stringify(startingAttributes));
    let time = 0;
    for (const group of onePerm) {
        // console.log('group', group)
        if(group.dataList) {
            for (const dataItem of group.dataList) {
                // console.log('dataItem', dataItem)
                const spPerMinute = calculateSPPerMinute(attributes[group.primary].total, attributes[group.secondary].total);
                const timeRequiredInMinutes = dataItem.requiredSP / spPerMinute;
                time += timeRequiredInMinutes;
                dataItem.trainingTimeOpt = timeRequiredInMinutes;
                dataItem.trainingTimeOptString = formatTime(timeRequiredInMinutes);
            }
        } else if (group.remap) {
            const remapAttrs = group.remap;
            // console.log('change remap', group.remap, remapAttrs)
            for (const att of attList) {
                const remapValue = remapAttrs[att] ? remapAttrs[att] : 0;
                attributes[att].remap = remapValue;
                attributes[att].total = attributes[att].base + attributes[att].implants + remapValue;
            }
        } 
    }
    return time
};
const calculateTimeForOnePermutation = (startingAttributes, onePerm) => {
    // console.log('calculateTimeForOnePermutation', onePerm)
    
    let attributes = JSON.parse(JSON.stringify(startingAttributes));

    let time = 0;
    for (const group of onePerm) {
        if(group.primary) {
            const spPerMinute = calculateSPPerMinute(attributes[group.primary].total, attributes[group.secondary].total);
        // // console.log('spPerMinute', attributes[primary].total, attributes[secondary].total, spPerMinute)
            const timeRequiredInMinutes = group.requiredSP / spPerMinute;
            time += timeRequiredInMinutes;
        } else if (group.remap) {
            const remapAttrs = allRemapCombinations[group.remap];
            // console.log('change remap', group.remap, remapAttrs)
            for (const att of attList) {
                const remapValue = remapAttrs[att] ? remapAttrs[att] : 0;
                attributes[att].remap = remapValue;
                attributes[att].total = attributes[att].base + attributes[att].implants + remapValue;
            }
        }
        
        // console.log('group', group, attributes, time)
    }

    return time
};
const optimiseSkillQueue = (skillsData, remapCount) => {
    // console.log('optimiseSkillQueue', skillsData, allRemapCombinations)
    
    const groupedSkillQueue = groupByPrimaryAndSecondary(skillsData.skillQueue.skills);
    for (let r = 0; r < remapCount; r++) {
        groupedSkillQueue.push({remap:allRemapCombinationsIndexList});
    }
    
    // console.log('groupedSkillQueue', groupedSkillQueue)

    const allPermutations = getSortingOrders(groupedSkillQueue);
    // console.log('allPermutations', allPermutations)
    // console.log('allRemapCombinations', allRemapCombinations)

    const exploded = explodeRemaps(allPermutations, remapCount);
    // console.log('exploded', exploded)

    let fastestTime = 9999999999999999999999999999;
    let fastestPermutation; 
    for (let i = 0; i < exploded.length; i++) {
    // for (let i = 12000; i < 12010; i++) {
        const onePermutation = exploded[i];
        const time = calculateTimeForOnePermutation(skillsData.attributes, onePermutation);
        if (time < fastestTime) {
            fastestTime = time;
            fastestPermutation = onePermutation;
        }
        // console.log('onePermutation', i, time)
    }
    const groupedSkillQueueWithDataList = groupByPrimaryAndSecondary(skillsData.skillQueue.skills, true);
    // console.log('groupedSkillQueueWithDataList', groupedSkillQueueWithDataList)

    
    fastestPermutation = fastestPermutation.map(f => {
        // console.log('f', f)
        if (f.remap !== undefined) {
            // console.log('remap')
            f.remap = allRemapCombinations[f.remap];
        } else {
            f.dataList = groupedSkillQueueWithDataList.find(g => g.primary === f.primary && g.secondary === f.secondary).dataList;

            // TODO - Need to correct the training time value for each dataList entry
            // f.dataList.forEach(d => {
            //     d.trainingTime
            // })
        }
        return f
    });
    const fastestTimeCheck = calculateIndividualTimesForFastestPermutation(skillsData.attributes, fastestPermutation);

    const fastestTimeString = formatTime(fastestTime, true);
    // TODO - Diff saving on fastest time
    console.log('fastest permutation', fastestTime, fastestTimeCheck, formatTime(fastestTime, true), fastestPermutation);
    return {fastestPermutation, fastestTime, fastestTimeString, remapCount}
};

const generateSkillLevels = (queuedLevel = 0, trainedLevel = 0, useBlank) => {
    const maxLevel = 5;
    let initialChar = 'e';
    if((queuedLevel > 0 && trainedLevel > 0)) initialChar = 'u';
    if(useBlank) initialChar = 'b';
    let result = initialChar.repeat(maxLevel);
    const q = 'q'.repeat(Math.min(maxLevel, queuedLevel));
    const t = 't'.repeat(Math.min(maxLevel, trainedLevel));
    for (const over of [q,t]) {
      for (let i = 0; i < over.length; i++) {
        result = result.slice(0, i) + over[i] + result.slice(i + 1);
      }
    }
    return result;
  };
 
const toRomanNumeral = (num) => {
    const romanNumerals = [
        { value: 5, numeral: 'V' },
        { value: 4, numeral: 'IV' },
        { value: 1, numeral: 'I' }
    ];
    let result = '';
    for (const { value, numeral } of romanNumerals) {
        while (num >= value) {
        result += numeral;
        num -= value;
        }
    }
    return result
};
  
  
const renderSkillImage = (queuedSkillLevel, trainedSkillLevel, useBlank) => {
    const template = generateSkillLevels(queuedSkillLevel, trainedSkillLevel, useBlank);
    return template.split('').map(v => `<span class="level-box ${v}"></span>`).join('')
};
const renderSkills = (datas) => {
    let html = '';
    // console.log('renderSkills', datas)
    html += `<h3>Skills <span class="text-secondary heading-small ps-3">${datas.skills.total_sp.toLocaleString()} SP Total</span></h3>`;

    html += `<div class="form-check form-switch">
        <input class="form-check-input" type="checkbox" role="switch" id="show-untrained-skills">
        <label class="form-check-label" for="show-untrained-skills">Show untrained skills</label>
    </div>`;

    for (const group of datas.categories.groups) {
        const groupSP = group.types.reduce((total, obj) => total + obj.skillpoints, 0);

        html += `<h5 class="mt-4">${group.name} <span class="text-secondary heading-xs ps-3">${groupSP.toLocaleString()} SP</span></h5>`;
        for (const type of group.types) {
            html += `<span class="level-container d-flex align-items-center${type.trainedSkillLevel>0?'':' untrained'}"${type.trainedSkillLevel>0?'':' style="display:none !important;"'}">`;
            // html += `${renderSkillImage(type)} <span class="text">${type.name} - ${type.trainedSkillLevel} - ${type.queuedSkillLevel} - ${type.skillpoints}</span>`
            html += `${renderSkillImage(type.queuedSkillLevel, type.trainedSkillLevel)} <span class="text ps-2 align-top">${type.name}</span>`;
            html +=  `</span>`;
        }
    }
    document.querySelector('.skills').innerHTML = html;
    document.querySelector('#show-untrained-skills').addEventListener('change', function() {
        document.querySelectorAll('.untrained').forEach((element) => {
            if(this.checked) {
                element.style.removeProperty('display');
            } else {
                element.style.setProperty('display', 'none', 'important');
            }
        });
    });
};
const renderQueue = (datas) => {
    let html = '';
    html += ` <h3 class="mb-3">Skill Queue <span class="text-secondary heading-small ps-3">${datas.skillQueue.skills.length} skills - ${datas.skillQueue.totalString}</span></h3>`;
    for (const skill of datas.skillQueue.skills) {
        html += `<span class="level-container d-flex align-items-center">`;
        html += `${renderSkillImage(skill.finished_level, skill.trainedSkillLevel, true)}`;
        html += `<span class="text ps-2 align-top">${skill.name} ${toRomanNumeral(skill.finished_level)}</span>`;
        html += `<span class="text ps-2 align-top text-highlight">${skill.primary.slice(0,1)} ${skill.secondary.slice(0,1)}</span>`;
        html += `<span class="text ps-2 align-top flex-fill"><span class="float-end">${skill.trainingTimeString}</span></span>`;
        html +=  `</span>`;
    }
    document.querySelector('.skills-queue').innerHTML = html;
};
const renderOptimisedQueueLoading = () => {
    document.querySelector('.skills-queue-optimised').innerHTML = 'Calculating optimised queue order and remappings ...';
};
const renderOptimisedQueue = (datas, optimised) => {
    // console.log('renderOptimisedQueue', datas, optimised)
    const attList = ['charisma','intelligence','memory','perception','willpower'];
    let html = '';
    html += ` <h3>Optimised Skill Queue <span class="text-secondary heading-small ps-3">${optimised.fastestTimeString}</span></h3>`;

    for (let i = 1; i <= 2; i++) { // TODO - Should probably take current time into account too
        html += `
            <div class="form-check form-check-inline mb-3">
            <input class="form-check-input" type="radio" name="remap-count" id="remap-count-${i}" value="${i}"${optimised.remapCount === i?' checked':''}>
            <label class="form-check-label" for="remap-count-${i}">${i} remap${i>1?'s':''}</label>
            </div>`;
    }

    for (const group of optimised.fastestPermutation) {
        if(group.remap) {
            // console.log('render remap', group)
            html += `<span class="level-container d-flex align-items-center justify-content-between border my-2">`;
            html += `<span class="text ps-2 align-top">REMAP</span>`;
            for (const att of attList) {
                const attValue = group.remap[att] ? group.remap[att] : 0;
                const nameShort = att.charAt(0).toUpperCase() + att.slice(1,3);

                html += `<span class="text ps-2 align-top pe-2${attValue>0?'': ' text-light-emphasis'}">${nameShort}: ${attValue}</span>`;
            }
            html += `</span>`;
        }
        if(group.dataList) {
            // console.log('render dataList', group)
            for (const skill of group.dataList) {
            html += `<span class="level-container d-flex align-items-center">`;
            html += `${renderSkillImage(skill.finished_level, skill.trainedSkillLevel, true)}`;
            html += `<span class="text ps-2 align-top">${skill.name} ${toRomanNumeral(skill.finished_level)}</span>`;
            html += `<span class="text ps-2 align-top text-highlight">${skill.primary.slice(0,1)} ${skill.secondary.slice(0,1)}</span>`;
            html += `<span class="text ps-2 align-top flex-fill"><span class="float-end">${skill.trainingTimeOptString}</span></span>`;
            html +=  `</span>`;
            }
        }
        
    }
    document.querySelector('.skills-queue-optimised').innerHTML = html;

    document.querySelectorAll('input[type="radio"][name="remap-count"]').forEach(btn => {
        btn.addEventListener('change', function(event) {
            const remapCount = parseInt(event.target.value);
            // console.log('remapCount', remapCount)
            renderOptimisedQueueLoading();
            setTimeout(() => {
                const optimised = optimiseSkillQueue(datas, remapCount);
                renderOptimisedQueue(datas, optimised);
            }, 100);
            
        });
    });
    

};
const renderCharacterPlaceholder = () => {
    let html = '';
    html += `
            <div class="col character">
            <div class="d-flex flex-nowrap">
                <div class="flex-grow-1 ps-2">
                    Loading...
                </div>
            </div>
            </div>`;
    document.querySelector('.info').insertAdjacentHTML("afterend", html);
};
const renderCharacter = (datas) => {
    loadData();
    let html = '';
    html += `
            <div class="d-flex flex-nowrap">
                <div class="flex-shrink-0">
                    <img src="https://images.evetech.net/characters/${datas.character.characterId}/portrait?size=256">
                </div>
                <div class="flex-grow-1 ps-2">
                    <h3>${datas.character.name}</h3>
                    <div class="attributes">
                </div>
            </div>`;
    document.querySelector('.character').innerHTML = html;

    // document.querySelector('.character').innerHTML = html
};
const renderAttributes = (datas) => {
    let html = '';
    html += `<table class="table table-borderless attributes-table">
        <thead>
        <tr>
            <th scope="col"></th>
            <th scope="col">Base</th>
            <th scope="col">Implant</th>
            <th scope="col">Remap</th>
            <th scope="col">Total</th>
        </tr>
        </thead>
        <tbody>
            ${['charisma','intelligence','memory','perception','willpower'].map(a => {
                return `<tr>
                    <th scope="row">${a.charAt(0).toUpperCase()}${a.slice(1)}</th>
                    <td>${datas.attributes[a].base}</td>
                    <td>+${datas.attributes[a].implants}</td>
                    <td>${datas.attributes[a].remap === 0 ? '' : datas.attributes[a].remap}</td>
                    <td>${datas.attributes[a].total}</td>
                </tr>`
            }).join('')}
        </tbody>
    </table>
    `;
    document.querySelector('.attributes').innerHTML = html;
};
const init = async () => {
    const isLoggedIn = await initLoginState();
    // console.log('isLoggedIn', isLoggedIn)
    if(isLoggedIn) {
        renderCharacterPlaceholder();
        const skillsData = await getSkillsData();
        renderCharacter(skillsData);
        renderAttributes(skillsData);
        renderSkills(skillsData);
        renderQueue(skillsData);

        renderOptimisedQueueLoading();
        setTimeout(() => {
            const remapCount = 1;
            const optimised = optimiseSkillQueue(skillsData, remapCount);
            renderOptimisedQueue(skillsData, optimised);
        }, 100);
    }
};

init();
